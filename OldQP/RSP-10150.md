# RSP-10150 - Cannot call Java instance methods called "init"

## Description

Please refer to [the issue](https://quality.embarcadero.com/browse/RSP-10150) for a description of the problem.

The issue has been closed as "Won't Fix", which is rather disappointing. Although the solution below means creating code **specific** to the `init` methods in question, I fully expect there would be a way of doing this in a generic fashion.

## Solution

### Background

This solution is specifically related to the class in question, i.e. the [`Cipher`](https://developer.android.com/reference/javax/crypto/Cipher.html) class, imported as `JCipher` in the JNI imports (`Androidapi.JNI.JavaTypes` unit)

Thanks mostly to Brian Long, from his [article published in the Delphi 10 Seattle era](http://blong.com/Articles/Delphi10NFC/NFC.htm), the way to call `init` methods is to use JNI methods which appear in the `Androidapi.JNI` unit.  (In Brian's article, scroll down to the section entitled "Controlling the foreground dispatch system")

### The code

It is assumed that this is part of code that is using a `PublicKey` (imported as `JPublicKey`) to initialize the `Cipher`, i.e. **`APublicKey` is a reference to a `JPublicKey`**, and the opmode of the `Cipher` is being passed as `AMode`. See below for possible values.

```delphi
uses
  Androidapi.JNI, Androidapi.JNI.JavaTypes;

var
  LEnv: PJniEnv;
  LCipher: JCipher;
  LCipherObject, LKeyObject: JNIObject;
  LCipherInit: JNIMethodID;
begin
  // Use the TJNIResolver helper to get a JNI environment reference
  LEnv := TJNIResolver.GetJNIEnv;
  // Convert the PublicKey instance to a JNIObject reference. Note that JObjectToID does not work for descendants of IJavaInstance (which JPublicKey is)
  LKeyObject := (APublicKey as ILocalObject).GetObjectID;
  // Create the Cipher with the relevant algorithm
  LCipher := TJCipher.JavaClass.getInstance(StringToJString('RSA/ECB/OAEPWithSHA-256AndMGF1Padding'));
  // Convert the Cipher instance to a JNIObject reference
  LCipherObject := JObjectToID(LCipher);
  // Get a class reference to Cipher, so that the relevant method(s) can be obtained
  LCipherClass := LEnv^.GetObjectClass(LEnv, LCipherObject);
  // Get a method reference for the init method
  LCipherInit := LEnv^.GetMethodID(LEnv, LCipherClass, 'init', '(ILjava/security/Key;)V');
  // Clean up the class reference
  LEnv^.DeleteLocalRef(LEnv, LCipherClass);
  // Invoke the method. Note that CallVoidMethodA is used here, meaning that the method does not have a result (Void), but it has arguments (A) 
  LEnv^.CallVoidMethodA(LEnv, LCipherObject, LCipherInit, PJNIValue(ArgsToJNIValues([AMode, LKeyObject])));
  // At this point, the init method should have been invoked
  // Normally, the code that follows the above would continue with the LCipher reference (i.e. no LCipherObject), since the other methods can be called on that reference
end;
```

### Explanation of the code

For the signature parameter of `GetMethodID`, it is a description of the method signature including parameters and return type. Since [this variant of the `init` method](https://developer.android.com/reference/javax/crypto/Cipher?hl=en#init(int,%20java.security.Key) is being called, it has 2 parameters:

* opmode - which is an int (`Integer`) (one of `ENCRYPT_MODE`, `DECRYPT_MODE`, `WRAP_MODE` or `UNWRAP_MODE`)
* key - in the example above, a `PublicKey` (imported as `JPublicKey`)

Where a parameter is a primitive type, it is represented by a single character - for int it is `I`. There is no separator after primitive types, so the next character is `L`, representing a reference to a Java type, followed a fully qualified name, and a semicolon - `Ljava/security/Key;`. Parameters are enclosed in parentheses, and finally if there is no result type, it is followed by `V` (i.e. void), thus the method signature for the version of the `init` method being used is: `(ILjava/security/Key;)V` 

In the `CallVoidMethodA` call, the JNI object reference to the instance in question is passed (`LCipherObject`), plus the method reference (`LCipherInit`), then an open array of the parameters, which are wrapped by the `ArgsToJNIValues` call.

## Calling other init methods, and/or methods that may be inaccesible

As described, the solution above is specific to calling a particular variant of the `init` method on the `Cipher` class, however the process can be changed to call any other `init` method, or perhaps a method that is otherwise normally inaccessible.

For instance, you may wish to call [this variant of `init`](https://developer.android.com/reference/javax/crypto/Cipher?hl=en#init(int,%20java.security.Key,%20java.security.spec.AlgorithmParameterSpec)) on the `Cipher` class, which accepts an `AlgorithmParameterSpec` as a *third* parameter. 

Regardless of the class, or the method name, these are the two critical aspects of making method calls this way:

* Ensure that any instances of Java classes referred to are "converted" to a JNIObject reference
* Ensure that the string for the signature *matches the method* in question, e.g. for this latest example: `'(ILjava/security/Key;Ljava/security/spec/AlgorithmParameterSpec;)V'`



